--- ipt_SYNPROXY.c.orig	2021-02-03 18:42:46.415465686 +0300
+++ ipt_SYNPROXY.c	2021-02-24 16:18:55.527425115 +0300
@@ -14,9 +14,13 @@
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter/xt_SYNPROXY.h>
 #include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
 #include <net/netfilter/nf_conntrack_seqadj.h>
 #include <net/netfilter/nf_conntrack_synproxy.h>
 
+#define SYNPROXY_IN_PROGRESS 1
+#define SYNPROXY_FINISH 2
+
 static struct iphdr *
 synproxy_build_ip(struct sk_buff *skb, __be32 saddr, __be32 daddr)
 {
@@ -72,7 +76,7 @@ free_nskb:
 
 static void
 synproxy_send_client_synack(const struct synproxy_net *snet,
-			    const struct sk_buff *skb, const struct tcphdr *th,
+			    struct sk_buff *skb, const struct tcphdr *th,
 			    const struct synproxy_options *opts)
 {
 	struct sk_buff *nskb;
@@ -82,6 +86,7 @@ synproxy_send_client_synack(const struct
 	u16 mss = opts->mss;
 
 	iph = ip_hdr(skb);
+	pr_debug("DBGSYN send synack %pI4 -> %pI4, mss %d\n", &iph->daddr, &iph->saddr, mss);
 
 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
@@ -102,13 +107,13 @@ synproxy_send_client_synack(const struct
 	if (opts->options & XT_SYNPROXY_OPT_ECN)
 		tcp_flag_word(nth) |= TCP_FLAG_ECE;
 	nth->doff	= tcp_hdr_size / 4;
-	nth->window	= 0;
+	nth->window	= 1;
 	nth->check	= 0;
 	nth->urg_ptr	= 0;
 
 	synproxy_build_options(nth, opts);
 
-	synproxy_send_tcp(snet, skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,
+	synproxy_send_tcp(snet, skb, nskb, NULL, IP_CT_ESTABLISHED_REPLY,
 			  niph, nth, tcp_hdr_size);
 }
 
@@ -121,6 +126,9 @@ synproxy_send_server_syn(const struct sy
 	struct iphdr *iph, *niph;
 	struct tcphdr *nth;
 	unsigned int tcp_hdr_size;
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
+	struct nf_conntrack *tmpl = &snet->tmpl->ct_general;
 
 	iph = ip_hdr(skb);
 
@@ -129,6 +137,7 @@ synproxy_send_server_syn(const struct sy
 			 GFP_ATOMIC);
 	if (nskb == NULL)
 		return;
+
 	skb_reserve(nskb, MAX_TCP_HEADER);
 
 	niph = synproxy_build_ip(nskb, iph->saddr, iph->daddr);
@@ -152,7 +161,36 @@ synproxy_send_server_syn(const struct sy
 
 	synproxy_build_options(nth, opts);
 
-	synproxy_send_tcp(snet, skb, nskb, &snet->tmpl->ct_general, IP_CT_NEW,
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if (ct) {
+		struct nf_conntrack_l4proto *l4proto;
+		unsigned int *timeouts;
+
+		l4proto = __nf_ct_l4proto_find(AF_INET, IPPROTO_TCP);
+		timeouts = l4proto->get_timeouts(nf_ct_net(ct));
+
+		/* Acquire the lock to avoid the possible race with tcp_packet */
+		spin_lock_bh(&ct->lock);
+		if (!l4proto->new(ct, nskb, skb_network_offset(nskb) + sizeof(*iph), timeouts)) {
+			nf_ct_kill(ct);
+			goto err;
+		}
+
+		if (!nfct_seqadj_ext_add(ct)) {
+			nf_ct_kill(ct);
+			goto err;
+		}
+		if (!nfct_synproxy_ext_add(ct)) {
+			nf_ct_kill(ct);
+			goto err;
+		}
+		tmpl = NULL;
+err:
+		spin_unlock_bh(&ct->lock);
+	}
+
+	synproxy_send_tcp(snet, skb, nskb, tmpl, IP_CT_NEW,
 			  niph, nth, tcp_hdr_size);
 }
 
@@ -266,6 +304,10 @@ synproxy_tg4(struct sk_buff *skb, const
 	struct synproxy_options opts = {};
 	struct tcphdr *th, _th;
 
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
+	ct = nf_ct_get(skb, &ctinfo);
+
 	if (nf_ip_checksum(skb, par->hooknum, par->thoff, IPPROTO_TCP))
 		return NF_DROP;
 
@@ -291,12 +333,20 @@ synproxy_tg4(struct sk_buff *skb, const
 					  XT_SYNPROXY_OPT_SACK_PERM |
 					  XT_SYNPROXY_OPT_ECN);
 
+		if (ct) {
+			nf_conntrack_confirm(skb);
+			ct->mark = SYNPROXY_IN_PROGRESS;
+		}
 		synproxy_send_client_synack(snet, skb, th, &opts);
 		return NF_DROP;
 
 	} else if (th->ack && !(th->fin || th->rst || th->syn)) {
 		/* ACK from client */
+		if (ct)
+			ct->mark = SYNPROXY_FINISH;
+
 		synproxy_recv_client_ack(snet, skb, th, &opts, ntohl(th->seq));
+
 		return NF_DROP;
 	}
 
@@ -320,6 +370,9 @@ static unsigned int ipv4_synproxy_hook(v
 	if (ct == NULL)
 		return NF_ACCEPT;
 
+	if (CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL && ct->mark == SYNPROXY_IN_PROGRESS)
+		return NF_DROP;
+
 	synproxy = nfct_synproxy(ct);
 	if (synproxy == NULL)
 		return NF_ACCEPT;
@@ -449,6 +502,57 @@ static struct nf_hook_ops ipv4_synproxy_
 	},
 };
 
+#define XT_SPSTATE_NONE 0
+#define XT_SPSTATE_IN_PROGRESS 1
+#define XT_SPSTATE_FINISH 2
+
+struct xt_spstate_mtinfo {
+	uint8_t state;
+	uint8_t invert;
+};
+
+static bool spstate_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	const struct xt_spstate_mtinfo *info = par->matchinfo;
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
+	bool result = false;
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if (!ct)
+		return true;
+
+	switch (info->state) {
+		case XT_SPSTATE_NONE:
+			result = ct->mark == 0;
+			break;
+		case XT_SPSTATE_IN_PROGRESS:
+			result = ct->mark == SYNPROXY_IN_PROGRESS;
+			break;
+		case XT_SPSTATE_FINISH:
+			result = ct->mark == SYNPROXY_FINISH;
+			break;
+		default:
+			return false;
+	}
+
+	if (info->invert) {
+		result = !result;
+	}
+
+	return result;
+}
+
+static struct xt_match spstate_mt_reg __read_mostly = {
+	.name             = "spstate",
+	.revision         = 0,
+	.family           = NFPROTO_IPV4,
+	.match            = spstate_mt,
+	.matchsize        = sizeof(struct xt_spstate_mtinfo),
+	.me               = THIS_MODULE,
+};
+
+
 static int __init synproxy_tg4_init(void)
 {
 	int err;
@@ -462,8 +566,14 @@ static int __init synproxy_tg4_init(void
 	if (err < 0)
 		goto err2;
 
+	err = xt_register_match(&spstate_mt_reg);
+	if (err < 0)
+		goto err3;
+
 	return 0;
 
+err3:
+	xt_unregister_target(&synproxy_tg4_reg);
 err2:
 	nf_unregister_hooks(ipv4_synproxy_ops, ARRAY_SIZE(ipv4_synproxy_ops));
 err1:
@@ -472,6 +582,7 @@ err1:
 
 static void __exit synproxy_tg4_exit(void)
 {
+	xt_unregister_match(&spstate_mt_reg);
 	xt_unregister_target(&synproxy_tg4_reg);
 	nf_unregister_hooks(ipv4_synproxy_ops, ARRAY_SIZE(ipv4_synproxy_ops));
 }
